<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocationGroup.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenWMS.org COMMON: Base Service Library</a> &gt; <a href="index.source.html" class="el_package">org.openwms.common.location</a> &gt; <span class="el_source">LocationGroup.java</span></div><h1>LocationGroup.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2005-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openwms.common.location;

import org.ameba.exception.ServiceLayerException;
import org.openwms.common.StateChangeException;
import org.openwms.common.account.Account;
import org.openwms.common.location.api.LocationGroupMode;
import org.openwms.common.location.api.LocationGroupState;
import org.springframework.util.Assert;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.ForeignKey;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;

/**
 * A LocationGroup is a logical group of {@code Location}s with same characteristics.
 *
 * @author Heiko Scherrer
 * @GlossaryTerm
 * @see org.openwms.common.location.Location
 */
@Entity
@Table(name = &quot;COM_LOCATION_GROUP&quot;, uniqueConstraints =
    @UniqueConstraint(name = &quot;UC_LG_NAME&quot;, columnNames = &quot;C_NAME&quot;)
)
public class LocationGroup extends Target implements Serializable {

    /** Unique identifier of a {@code LocationGroup}. */
    @Column(name = &quot;C_NAME&quot;, nullable = false, length = LENGTH_NAME)
    @NotBlank
    @Size(min = 1, max = LENGTH_NAME)
    private String name;
    /** Length of the name field; used for telegram mapping and for column definition. */
    public static final int LENGTH_NAME = 255;

    /** The LocationGroup might be assigned to an {@link Account}. */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;C_ACCOUNT&quot;, referencedColumnName = &quot;C_IDENTIFIER&quot;, foreignKey = @ForeignKey(name = &quot;FK_LG_ACC&quot;))
    private Account account;

    /** Description of the {@code LocationGroup}. */
    @Column(name = &quot;C_DESCRIPTION&quot;)
    private String description;

    /** A type can be assigned to a {@code LocationGroup}. */
    @Column(name = &quot;C_GROUP_TYPE&quot;)
    private String groupType;

    /** Is the {@code LocationGroup} included in the calculation of {@code TransportUnit}s. */
<span class="fc" id="L80">    @Column(name = &quot;C_GROUP_COUNTING_ACTIVE&quot;)</span>
    private boolean locationGroupCountingActive = true;

    /** The operation mode is controlled by the subsystem and defines the physical mode a {@code LocationGroup} is currently able to operate in. */
<span class="fc" id="L84">    @Column(name = &quot;C_OP_MODE&quot;)</span>
    @NotBlank
    private String operationMode = LocationGroupMode.INFEED_AND_OUTFEED;

    /** State of infeed, controlled by the subsystem only. */
<span class="fc" id="L89">    @Column(name = &quot;C_GROUP_STATE_IN&quot;)</span>
    @Enumerated(EnumType.STRING)
    @NotNull
    private LocationGroupState groupStateIn = LocationGroupState.AVAILABLE;

    /** References the {@code LocationGroup} that locked this {@code LocationGroup} for infeed. */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;C_IN_LOCKER&quot;, foreignKey = @ForeignKey(name = &quot;FK_LG_LG_INLOCKER&quot;))
    private LocationGroup stateInLocker;

    /** State of outfeed. */
<span class="fc" id="L100">    @Column(name = &quot;C_GROUP_STATE_OUT&quot;)</span>
    @Enumerated(EnumType.STRING)
    @NotNull
    private LocationGroupState groupStateOut = LocationGroupState.AVAILABLE;

    /** References the {@code LocationGroup} that locked this {@code LocationGroup} for outfeed. */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;C_OUT_LOCKER&quot;, foreignKey = @ForeignKey(name = &quot;FK_LG_LG_OUTLOCKER&quot;))
    private LocationGroup stateOutLocker;

    /** Maximum fill level of the {@code LocationGroup}. */
<span class="fc" id="L111">    @Column(name = &quot;C_MAX_FILL_LEVEL&quot;)</span>
    private float maxFillLevel = 0;

    /** The subsystem like a PLC, that manages this {@code LocationGroup}. */
    @Embedded
    private Subsystem subsystem;

    /* ------------------- collection mapping ------------------- */
    /** Parent {@code LocationGroup}. */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;C_PARENT&quot;, foreignKey = @ForeignKey(name = &quot;FK_LG_LG_PARENT&quot;))
    private LocationGroup parent;

    /** Child {@code LocationGroup}s. */
<span class="fc" id="L125">    @OneToMany(mappedBy = &quot;parent&quot;, cascade = {CascadeType.ALL})</span>
    private Set&lt;LocationGroup&gt; locationGroups = new HashSet&lt;&gt;();

    /** Child {@link Location}s. */
<span class="fc" id="L129">    @OneToMany(mappedBy = &quot;locationGroup&quot;)</span>
    private Set&lt;Location&gt; locations = new HashSet&lt;&gt;();

    /*~ ----------------------------- constructors ------------------- */
    /** Dear JPA... */
<span class="fc" id="L134">    protected LocationGroup() { }</span>

    /**
     * Create a new {@code LocationGroup} with a unique name.
     *
     * @param name The name of the {@code LocationGroup} must not be {@literal null}
     */
<span class="fc" id="L141">    public LocationGroup(@NotBlank String name) {</span>
<span class="fc" id="L142">        Assert.hasText(name, &quot;Creation of LocationGroup with name null&quot;);</span>
<span class="fc" id="L143">        this.name = name;</span>
<span class="fc" id="L144">    }</span>

    /*~ ----------------------------- methods ------------------- */

    /**
     * Returns the name of the {@code LocationGroup}.
     *
     * @return The name of the {@code LocationGroup}
     */
    public String getName() {
<span class="fc" id="L154">        return name;</span>
    }

    /**
     * Return the {@link Account} this {@code LocationGroup} is assigned to.
     *
     * @return The {@link Account}
     */
    public Account getAccount() {
<span class="fc" id="L163">        return account;</span>
    }

    /**
     * Sets the {@link Account} for this {@code LocationGroup}.
     *
     * @param account The {@link Account} to set for this {@code LocationGroup}
     */
    public void setAccount(Account account) {
<span class="fc" id="L172">        this.account = account;</span>
<span class="fc" id="L173">    }</span>

    /**
     * Check whether infeed is allowed for the {@code LocationGroup}.
     *
     * @return {@literal true} if allowed, otherwise {@literal false}.
     */
    public boolean isInfeedAllowed() {
<span class="fc bfc" id="L181" title="All 2 branches covered.">        return (getGroupStateIn() == LocationGroupState.AVAILABLE);</span>
    }

    /**
     * Check whether infeed of the {@code LocationGroup} is blocked.
     *
     * @return {@literal true} if blocked, otherwise {@literal false}.
     */
    public boolean isInfeedBlocked() {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        return !isInfeedAllowed();</span>
    }

    /**
     * Check whether outfeed is allowed for the {@code LocationGroup}.
     *
     * @return {@literal true} if allowed, otherwise {@literal false}.
     */
    public boolean isOutfeedAllowed() {
<span class="fc bfc" id="L199" title="All 2 branches covered.">        return (getGroupStateOut() == LocationGroupState.AVAILABLE);</span>
    }

    /**
     * Check whether outfeed of the {@code LocationGroup} is blocked.
     *
     * @return {@literal true} if blocked, otherwise {@literal false}.
     */
    public boolean isOutfeedBlocked() {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        return !isOutfeedAllowed();</span>
    }

    /**
     * Get the current operation mode this {@code LocationGroup} operates in.
     *
     * @return The operational mode
     */
    public String getOperationMode() {
<span class="fc" id="L217">        return operationMode;</span>
    }

    /**
     * Set the current operation mode this {@code LocationGroup} can operate in.
     *
     * @param operationMode The mode as an extensible String
     * @see LocationGroupMode
     */
    public void setOperationMode(@NotBlank String operationMode) {
<span class="fc" id="L227">        this.operationMode = operationMode;</span>
<span class="fc" id="L228">        this.locationGroups.forEach(lg -&gt; lg.setOperationMode(operationMode));</span>
<span class="fc" id="L229">    }</span>

    /**
     * Returns the infeed state of the {@code LocationGroup}.
     *
     * @return The state of infeed
     */
    public LocationGroupState getGroupStateIn() {
<span class="fc" id="L237">        return this.groupStateIn;</span>
    }

    /**
     * Change the infeed state of the {@code LocationGroup}.
     *
     * @param newGroupStateIn The state to set
     */
    public void changeGroupStateIn(LocationGroupState newGroupStateIn) {
<span class="pc bpc" id="L246" title="1 of 4 branches missed.">        if (stateInLocker != null &amp;&amp; stateInLocker != this) {</span>
<span class="fc" id="L247">            throw new StateChangeException(&quot;The LocationGroup's state is blocked by any other LocationGroup and cannot be changed&quot;);</span>
        }
<span class="fc" id="L249">        groupStateIn = newGroupStateIn;</span>
<span class="fc" id="L250">        locationGroups.forEach(lg -&gt; lg.changeGroupStateIn(newGroupStateIn, this));</span>
<span class="fc" id="L251">    }</span>

    /**
     * Change the infeed state of the {@code LocationGroup}.
     *
     * @param newGroupStateIn The state to set
     * @param lockLG The {@code LocationGroup} that wants to lock/unlock this {@code LocationGroup}.
     */
    private void changeGroupStateIn(LocationGroupState newGroupStateIn, LocationGroup lockLG) {
<span class="pc bpc" id="L260" title="1 of 4 branches missed.">        if (groupStateIn == LocationGroupState.NOT_AVAILABLE &amp;&amp; newGroupStateIn == LocationGroupState.AVAILABLE) {</span>

            // unlock
<span class="fc" id="L263">            stateInLocker = null;</span>
        }
<span class="fc bfc" id="L265" title="All 4 branches covered.">        if (groupStateIn == LocationGroupState.AVAILABLE &amp;&amp; newGroupStateIn == LocationGroupState.NOT_AVAILABLE) {</span>

            // lock
<span class="fc" id="L268">            stateInLocker = lockLG;</span>
        }
<span class="fc" id="L270">        groupStateIn = newGroupStateIn;</span>
<span class="fc" id="L271">        locationGroups.forEach(lg -&gt; lg.changeGroupStateIn(newGroupStateIn, lockLG));</span>
<span class="fc" id="L272">    }</span>

    /**
     * Return the outfeed state of the {@code LocationGroup}.
     *
     * @return The state of outfeed
     */
    public LocationGroupState getGroupStateOut() {
<span class="fc" id="L280">        return groupStateOut;</span>
    }

    /**
     * Change the outfeed state of the {@code LocationGroup}.
     *
     * @param newGroupStateOut The state to set
     */
    public void changeGroupStateOut(LocationGroupState newGroupStateOut) {
<span class="pc bpc" id="L289" title="3 of 4 branches missed.">        if (stateOutLocker != null &amp;&amp; stateOutLocker != this) {</span>
<span class="nc" id="L290">            throw new StateChangeException(&quot;The LocationGroup's state is blocked by any other LocationGroup and cannot be changed&quot;);</span>
        }
<span class="fc" id="L292">        groupStateOut = newGroupStateOut;</span>
<span class="fc" id="L293">        locationGroups.forEach(lg -&gt; lg.changeGroupStateOut(newGroupStateOut, this));</span>
<span class="fc" id="L294">    }</span>

    /**
     * Set the outfeed state of the {@code LocationGroup}.
     *
     * @param gStateOut The state to set
     * @param lockLg The {@code LocationGroup} that wants to lock/unlock this {@code LocationGroup}.
     */
    void changeGroupStateOut(LocationGroupState gStateOut, LocationGroup lockLg) {
<span class="pc bpc" id="L303" title="3 of 8 branches missed.">        if (this.groupStateOut == LocationGroupState.NOT_AVAILABLE &amp;&amp; gStateOut == LocationGroupState.AVAILABLE &amp;&amp; (this.stateOutLocker == null || this.stateOutLocker.equals(lockLg))) {</span>
<span class="fc" id="L304">            this.groupStateOut = gStateOut;</span>
<span class="fc" id="L305">            this.stateOutLocker = null;</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            for (LocationGroup child : locationGroups) {</span>
<span class="fc" id="L307">                child.changeGroupStateOut(gStateOut, lockLg);</span>
<span class="fc" id="L308">            }</span>
        }
<span class="pc bpc" id="L310" title="4 of 8 branches missed.">        if (this.groupStateOut == LocationGroupState.AVAILABLE &amp;&amp; gStateOut == LocationGroupState.NOT_AVAILABLE &amp;&amp; (this.stateOutLocker == null || this.stateOutLocker.equals(lockLg))) {</span>
<span class="fc" id="L311">            this.groupStateOut = gStateOut;</span>
<span class="fc" id="L312">            this.stateOutLocker = lockLg;</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            for (LocationGroup child : locationGroups) {</span>
<span class="fc" id="L314">                child.changeGroupStateOut(gStateOut, lockLg);</span>
<span class="fc" id="L315">            }</span>
        }
<span class="fc" id="L317">    }</span>

    /**
     * Returns the count of all sub {@link Location}s.
     *
     * @return The count of {@link Location}s belonging to this {@code LocationGroup}
     */
    public int getNoLocations() {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        return this.locations != null ? this.locations.size() : 0;</span>
    }

    /**
     * Returns the maximum fill level of the {@code LocationGroup}.&lt;br&gt; The maximum fill level defines how many {@link Location}s of the
     * {@code LocationGroup} can be occupied by {@code TransportUnit}s. &lt;p&gt; The maximum fill level is a value between 0 and 1 and represents
     * a percentage value. &lt;/p&gt;
     *
     * @return The maximum fill level
     */
    public float getMaxFillLevel() {
<span class="fc" id="L336">        return this.maxFillLevel;</span>
    }

    /**
     * Set the maximum fill level for the {@code LocationGroup}. &lt;p&gt; Pass a value between 0 and 1.&lt;br&gt; For example maxFillLevel = 0.85
     * means: 85% of all {@link Location}s can be occupied. &lt;/p&gt;
     *
     * @param maxFillLevel The maximum fill level
     */
    public void setMaxFillLevel(float maxFillLevel) {
<span class="nc" id="L346">        this.maxFillLevel = maxFillLevel;</span>
<span class="nc" id="L347">    }</span>

    /**
     * Returns the type of the {@code LocationGroup}.
     *
     * @return The type of the {@code LocationGroup}
     */
    public String getGroupType() {
<span class="fc" id="L355">        return this.groupType;</span>
    }

    /**
     * Set the type for the {@code LocationGroup}.
     *
     * @param groupType The type of the {@code LocationGroup}
     */
    public void setGroupType(String groupType) {
<span class="fc" id="L364">        this.groupType = groupType;</span>
<span class="fc" id="L365">    }</span>

    /**
     * Returns the description text.
     *
     * @return The Description as String
     */
    public String getDescription() {
<span class="fc" id="L373">        return this.description;</span>
    }

    /**
     * Set the description text.
     *
     * @param description The String to set as description text
     */
    public void setDescription(String description) {
<span class="fc" id="L382">        this.description = description;</span>
<span class="fc" id="L383">    }</span>

    /**
     * Returns the parent {@code LocationGroup}.
     *
     * @return The parent {@code LocationGroup}
     */
    public LocationGroup getParent() {
<span class="fc" id="L391">        return this.parent;</span>
    }

    /**
     * Sets the parent {@code LocationGroup} of this {@code LocationGroup}.
     *
     * @param parent The parent {@code LocationGroup} to set
     */
    public void setParent(LocationGroup parent) {
<span class="fc" id="L400">        this.parent = parent;</span>
<span class="fc" id="L401">    }</span>

    /**
     * Return all child {@code LocationGroup}.
     *
     * @return A set of all {@code LocationGroup} having this one as parent
     */
    public Set&lt;LocationGroup&gt; getLocationGroups() {
<span class="fc" id="L409">        return locationGroups;</span>
    }

    /**
     * Sets the child {@code LocationGroup}.
     *
     * @param locationGroups the set of LocationGroups to set
     */
    public void setLocationGroups(Set&lt;LocationGroup&gt; locationGroups) {
<span class="fc" id="L418">        this.locationGroups = locationGroups;</span>
<span class="fc" id="L419">    }</span>

    /**
     * Add a {@code LocationGroup} to the list of children.
     *
     * @param locationGroup The {@code LocationGroup} to be added as a child
     * @return {@literal true} if the {@code LocationGroup} was new in the collection of {@code LocationGroup}s, otherwise {@literal false}
     */
    public boolean addLocationGroup(LocationGroup locationGroup) {
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (locationGroup == null) {</span>
<span class="fc" id="L429">            throw new IllegalArgumentException(&quot;LocationGroup to be added is null&quot;);</span>
        }
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (locationGroup.parent != null) {</span>
<span class="fc" id="L432">            locationGroup.parent.removeLocationGroup(locationGroup);</span>
        }
<span class="fc" id="L434">        locationGroup.parent = this;</span>
<span class="fc" id="L435">        locationGroup.changeGroupStateIn(groupStateIn, this);</span>
<span class="fc" id="L436">        locationGroup.changeGroupStateOut(groupStateOut, this);</span>
<span class="fc" id="L437">        return locationGroups.add(locationGroup);</span>
    }

    /**
     * Remove a {@code LocationGroup} from the list of children.
     *
     * @param locationGroup The {@code LocationGroup} to be removed from the list of children
     * @return {@literal true} if the {@code LocationGroup} was found and could be removed, otherwise {@literal false}
     */
    public boolean removeLocationGroup(@NotNull LocationGroup locationGroup) {
<span class="pc" id="L447">        Assert.notNull(locationGroup, () -&gt; &quot;LocationGroup to remove is null. this: &quot; + this);</span>
<span class="fc" id="L448">        locationGroup.parent = null;</span>
<span class="fc" id="L449">        return locationGroups.remove(locationGroup);</span>
    }

    /**
     * Return all {@link Location}s.
     *
     * @return {@link Location}s
     */
    public Set&lt;Location&gt; getLocations() {
<span class="fc" id="L458">        return locations;</span>
    }

    /**
     * Check whether this {@code LocationGroup} has {@code Location}s assigned.
     *
     * @return {@literal true} if {@code Location}s are assigned, otherwise {@literal false}
     */
    public boolean hasLocations() {
<span class="pc bpc" id="L467" title="1 of 4 branches missed.">        return locations != null &amp;&amp; !locations.isEmpty();</span>
    }

    /**
     * Add a {@link Location} to the list of children.
     *
     * @param location The {@link Location} to be added as child
     * @return {@literal true} if the {@link Location} was new in the collection of {@link Location}s, otherwise {@literal false}
     */
    public boolean addLocation(Location location) {
<span class="fc" id="L477">        Assert.notNull(location, () -&gt; &quot;Location to be added to LocationGroup is null. this: &quot; + this);</span>
<span class="fc" id="L478">        location.setLocationGroup(this);</span>
<span class="fc" id="L479">        return locations.add(location);</span>
    }

    /**
     * Remove a {@link Location} from the list of children.
     *
     * @param location The {@link Location} to be removed from the list of children
     * @return {@literal true} if the {@link Location} was found and could be removed, otherwise {@literal false}
     */
    public boolean removeLocation(Location location) {
<span class="fc" id="L489">        Assert.notNull(location, () -&gt; &quot;Location to remove from LocationGroup is null. this: &quot; + this);</span>
<span class="fc" id="L490">        location.unsetLocationGroup();</span>
<span class="fc" id="L491">        return locations.remove(location);</span>
    }

    /**
     * Returns the locationGroupCountingActive.
     *
     * @return The locationGroupCountingActive
     */
    public boolean isLocationGroupCountingActive() {
<span class="fc" id="L500">        return locationGroupCountingActive;</span>
    }

    /**
     * Set the locationGroupCountingActive.
     *
     * @param locationGroupCountingActive The locationGroupCountingActive to set
     */
    public void setLocationGroupCountingActive(boolean locationGroupCountingActive) {
<span class="fc" id="L509">        this.locationGroupCountingActive = locationGroupCountingActive;</span>
<span class="fc" id="L510">    }</span>

    /**
     * {@inheritDoc}
     *
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
<span class="fc" id="L519">        final int prime = 31;</span>
<span class="fc" id="L520">        int result = 111;</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">        result = prime * result + ((name == null) ? 0 : name.hashCode());</span>
<span class="fc" id="L522">        return result;</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L533">            return true;</span>
        }
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        if (!(obj instanceof LocationGroup)) {</span>
<span class="nc" id="L536">            return false;</span>
        }
<span class="fc" id="L538">        LocationGroup other = (LocationGroup) obj;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            if (other.name != null) {</span>
<span class="nc" id="L541">                return false;</span>
            }
<span class="fc bfc" id="L543" title="All 2 branches covered.">        } else if (!name.equals(other.name)) {</span>
<span class="fc" id="L544">            return false;</span>
        }
<span class="fc" id="L546">        return true;</span>
    }

    /**
     * Return the name of the {@code LocationGroup} as String.
     *
     * @return The name
     */
    @Override
    public String toString() {
<span class="fc" id="L556">        return getName();</span>
    }

    /**
     * Tries to change the {@code groupStateIn} and {@code groupStateOut} of the {@code LocationGroup}. A state change is only allowed when
     * the parent {@code LocationGroup}s state is not blocked.
     *
     * @param stateIn The new groupStateIn to set, or {@literal null}
     * @param stateOut The new groupStateOut to set, or {@literal null}
     */
    public void changeState(LocationGroupState stateIn, LocationGroupState stateOut) {
<span class="pc bpc" id="L567" title="1 of 4 branches missed.">        if (groupStateIn != stateIn &amp;&amp; stateIn != null) {</span>
            // GroupStateIn changed
<span class="pc bpc" id="L569" title="4 of 6 branches missed.">            if (parent != null &amp;&amp; parent.getGroupStateIn() == LocationGroupState.NOT_AVAILABLE &amp;&amp; groupStateIn == LocationGroupState.AVAILABLE) {</span>
<span class="nc" id="L570">                throw new ServiceLayerException(&quot;Not allowed to change GroupStateIn, parent locationGroup is not available&quot;);</span>
            }
<span class="fc" id="L572">            changeGroupStateIn(stateIn, this);</span>
        }
<span class="pc bpc" id="L574" title="1 of 4 branches missed.">        if (groupStateOut != stateOut &amp;&amp; stateOut != null) {</span>
            // GroupStateOut changed
<span class="pc bpc" id="L576" title="4 of 6 branches missed.">            if (parent != null &amp;&amp; parent.getGroupStateOut() == LocationGroupState.NOT_AVAILABLE &amp;&amp; groupStateOut == LocationGroupState.AVAILABLE) {</span>
<span class="nc" id="L577">                throw new ServiceLayerException(&quot;Not allowed to change GroupStateOut, parent locationGroup is not available&quot;);</span>
            }
<span class="fc" id="L579">            changeGroupStateOut(stateOut, this);</span>
        }
<span class="fc" id="L581">    }</span>

    /**
     * Whether this LocationGroup has a parent LocationGroup or not.
     *
     * @return {@literal true} If it has a parent
     */
    public boolean hasParent() {
<span class="fc bfc" id="L589" title="All 2 branches covered.">        return parent != null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>